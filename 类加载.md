类加载机制——双亲委派
===

#	阶段
1. 加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。
2. 第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：
	* 验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。
	* 准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。
	* 解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。符号引用像占位符，直接引用是在内存分配完成后，拥有内存地址的引用。[二者区别](https://blog.csdn.net/u014656992/article/details/51107127)
3. 初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。



# 作用
* 效率

	子类加载器执行时会委托给父加载器加载，不重复加载。*但是反过来是不允许的。*
	
* 安全

	像Java的原始类库，比如String 类是不能被你自定义的String类替换的。
	
	
# 联想 热修复技术

比如 [Tinker](https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286426&idx=1&sn=eb75349c0c3663f10fbdd74ef87be338&chksm=8334c398b4434a8e6933ddb4fda4a4f06c729c7d2ffef37e4598cb90f4602f5310486b7f95ff#rd)，客户端下载到补丁包之后会进行全量合成，生成新的Dex文件，然后放到dexPathList头部，这样DexClassLoader加载时就会先加载新包，而废弃旧包。