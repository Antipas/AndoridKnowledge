锁机制
===

线程安全需要保证几个基本特性：

 * **原子性**，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
 * **内存可见性**，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
 * **指令重排序**，是保证线程内串行语义，避免指令重排等。

# Synchronized
1. synchronized 是 Java 内建的同步机制，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里.

2. 反编译之后可以发现，它利用了 monitorenter/monitorexit 对实现了同步的语义：


	
		11: astore_1
		12: monitorenter
		13: aload_0
		14: dup
		15: getfield  	#2              	// Field sharedState:I
		18: dup_x1
		…
		56: monitorexit

3. 使用 synchronized 修饰 **静态方法** 时，其等同于利用下面代码将方法体囊括进来：

	```
	synchronized (ClassName.class) {}
	```
4. 不公平锁
5. synchronized不能中断锁



# ReentrantLock
1. ReentrantLock，通常翻译为再入锁，是 Java 5 提供的锁实现，它的语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。与此同时，ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。
2. 这里所谓的公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。

	```
		ReentrantLock fairLock = new ReentrantLock(true);
	```
	
3. 这样使用：

	```
		ReentrantLock fairLock = new ReentrantLock(true);
		fairLock.lock();
		try {
			// do something
		} finally {
			//	这里就像数据库游标、流的关闭操作一样
		 	fairLock.unlock();
		}
	
	```
4. ReentrantLock 内部的Sync 继承自AQS。加锁的时候通过CAS，将线程对象放到一个双向链表中，然后每次取出链表中的头节点，看这个节点的线程ID是否和当前线程相等。

# Condition
1. Condition 则是将 wait、notify、notifyAll 等操作转化为相应的对象，将复杂而晦涩的同步操作转变为直观可控的对象行为
2. 通过 signal/await 的组合，完成了条件判断和通知等待线程，非常顺畅就完成了状态流转。注意，signal 和 await 成对调用非常重要，不然假设只有 await 动作，线程会一直等待直到被打断（interrupt）

	```
	详细见ArrayBlockingQueue源码的 take() 和enqueue()

# 比较
1. 用法比较：
Lock使用起来比较灵活，但是必须有释放锁的配合动作
Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁
Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等 

2. 特性比较：
ReentrantLock的优势体现在：
具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放
超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回

3. 注意事项：
在使用ReentrantLock类的时，一定要注意三点：
在finally中释放锁，目的是保证在获取锁之后，最终能够被释放
不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。
ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。



# 锁的升级降级
现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。

1. 当没有竞争出现时，默认会使用偏向锁。JVM 会利用 CAS 操作，在 [对象头](http://www.importnew.com/23605.html) 上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏向锁可以降低无竞争开销。
2. 如果有另外的线程试图锁定某个已经被偏向过的对象，JVM 就需要撤销（revoke）偏向锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。
3. 当JVM进入安全点(联想GC)的时候，会检查是否有闲置的 Monitor，然后试图进行降级。

# 自旋锁
1. 自旋锁:竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。
2. 适用场景:自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。
如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费。
3. 单cpu无效，因为基于cas的轮询会占用cpu,导致无法做线程切换
