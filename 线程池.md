# 线程池

* 记住构造方法：
                              
	```
	ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
   ```
   * corePoolSize：核心线程大小
   * maximumPoolSize：最大线程数量，= 核心线程 + 空闲线程
   * keepAliveTime、unit： 空闲线程能活多久
   * workQueue：内部容器类型
   * threadFactory：自己实现线程工厂
   * handler：自己实现拒绝策略
* 内部容器BlockingQueue：具体实现：LinkedBlockingQueue（无界队列）、 ArrayBlockingQueue（有界队列）等
* 每一个任务都封装成了Worker并继承AQS抽象类
* [什么是AQS？](http://ifeve.com/java-special-troops-aqs/)
* 拒绝策略：
	* DiscardPolicy，新任务直接丢弃
	* DiscardOldestPolicy， 丢弃最早入队的任务
	* AbortPolicy，throw报错
	* CallerRunsPolicy，让当前线程执行该任务


#联想Rxjava的背压
	
背压是指在__异步场景__中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略，简而言之，背压是流速控制的一种策略。

* 背压策略的一个前提是异步环境，也就是说，被观察者和观察者处在不同的线程环境中。
* 背压并不是一个像flatMap一样可以在程序中直接使用的操作符，他只是一种控制事件流速的策略。

#策略：

* sample操作符，丢弃
* buffer操作符，把多余事件放到缓存池慢慢处理
* onBackpressurebuffer操作符：把observable发送出来的事件做缓存，当request方法被调用的时候，给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常)。
* onBackpressureDrop操作符：将observable发送的事件抛弃掉，直到subscriber再次调用request（n）方法的时候，就发送给它这之后的n个事件。
* [Rxjava2是怎么处理的](https://www.jianshu.com/p/ceb48ed8719d)