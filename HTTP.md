HTTP
===

# HTTP 请求的准备
比如请求的URL是 github.com，首先会让通过DNS解析域名，然后TCP的三次握手建立连接


# 请求体的构建
1. 请求行
2. Header
3. 请求体

## 请求行
* URL
* 版本（下文的1.1、2.0）
* 方法：GET、POST、PUT、DELETE

## Header
* Accept-Charset，表示客户端可以接受的字符集。
* Content-Type是指正文的格式。json、xml
* Cache-control是用来控制缓存的的。当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群。
* If-Modified-Since。也是一个关于缓存的。也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回“304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽。
* [缓存详细介绍](https://www.jianshu.com/p/0c31b58dbccb)
* Retry-After表示，告诉客户端应该在多长时间以后再次尝试一下。“503 错误”是说“服务暂时不再和这个值配合使用”。

# HTTP 1.1
HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。




# HTTP 2.0

**HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能。**



# 区别：
* Header压缩。为了解决上述问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key  value 在两端建立一个索引表，对相同的头只发送索引表中的索引。
* 另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。
* HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有：
	* Header帧，用于传输 Header 内容，并且会开启一个新的流。
	* Data帧，用来传输正文实体。多个 Data 帧属于同一个流。

* 通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。

* 假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。**HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。**


[多路复用](https://segmentfault.com/a/1190000011172823)